/* Generated by Nimrod Compiler v0.8.10 */
/*   (c) 2010 Andreas Rumpf */

typedef long long int NI;
typedef unsigned long long int NU;
#include "nimbase.h"

typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TY39422 TY39422;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY10802 TY10802;
typedef struct TY10818 TY10818;
typedef struct TY11190 TY11190;
typedef struct TY10814 TY10814;
typedef struct TY10810 TY10810;
typedef struct TY11188 TY11188;
typedef struct TY47635 TY47635;
typedef struct TY47532 TY47532;
struct TGenericSeq {
NI len;
NI space;
};
typedef NIM_CHAR TY239[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY239 data;
};
typedef NimStringDesc* TY47239[235];
typedef NimStringDesc* TY47474[15];
typedef NimStringDesc* TY47494[13];
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct TY10802 {
NI Refcount;
TNimType* Typ;
};
struct TY10818 {
NI Len;
NI Cap;
TY10802** D;
};
struct TY10814 {
NI Counter;
NI Max;
TY10810* Head;
TY10810** Data;
};
struct TY11188 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
};
struct TY11190 {
TY10818 Zct;
TY10818 Decstack;
TY10814 Cycleroots;
TY10818 Tempstack;
NI Cyclerootslock;
NI Zctlock;
TY11188 Stat;
};
struct TY47532 {
NI16 Line;
NI16 Col;
int Fileindex;
};
typedef NimStringDesc* TY48018[4];
typedef NimStringDesc* TY47865[1];
typedef NimStringDesc* TY72066[3];
typedef NI TY8814[8];
struct TY10810 {
TY10810* Next;
NI Key;
TY8814 Bits;
};
struct TY39422 {
  TGenericSeq Sup;
  NimStringDesc* data[SEQ_DECL_SIZE];
};
struct TY47635 {
  TGenericSeq Sup;
  TY47532 data[SEQ_DECL_SIZE];
};
N_NIMCALL(void*, newSeq)(TNimType* Typ_14204, NI Len_14205);
static N_INLINE(void, asgnRefNoCycle)(void** Dest_13218, void* Src_13219);
static N_INLINE(TY10802*, Usrtocell_11612)(void* Usr_11614);
static N_INLINE(NI, Atomicinc_3001)(NI* Memloc_3004, NI X_3005);
static N_INLINE(NI, Atomicdec_3006)(NI* Memloc_3009, NI X_3010);
static N_INLINE(void, Rtladdzct_12601)(TY10802* C_12603);
N_NOINLINE(void, Addzct_11601)(TY10818* S_11604, TY10802* C_11605);
N_NIMCALL(NI, Includefilename_47611)(NimStringDesc* F_47613);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* A_18647, NimStringDesc* B_18648);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* Seq_19003, NI Elemsize_19004, NI Newlen_19005);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* Src_18708);
N_NIMCALL(void, Writecontext_47994)(TY47532 Lastinfo_47996);
N_NIMCALL(NIM_BOOL, Samelineinfo_47985)(TY47532 A_47987, TY47532 B_47988);
N_NIMCALL(void, Messageout_47550)(NimStringDesc* S_47552);
N_NIMCALL(NimStringDesc*, nsuFormatOpenArray)(NimStringDesc* Formatstr_24965, NimStringDesc** A_24967, NI A_24967Len0);
N_NIMCALL(NimStringDesc*, Tofilename_47579)(TY47532 Info_47581);
N_NIMCALL(NimStringDesc*, Coordtostr_47846)(NI Coord_47848);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI X_19403);
N_NIMCALL(NimStringDesc*, Getmessagestr_47858)(NU8 Msg_47860, NimStringDesc* Arg_47861);
N_NIMCALL(NimStringDesc*, Msgkindtostring_47588)(NU8 Kind_47590);
N_NIMCALL(void, Limessage_47562)(TY47532 Info_47564, NU8 Msg_47565, NimStringDesc* Arg_47566);
N_NIMCALL(void, Handleerror_47919)(NU8 Msg_47921);
N_NIMCALL(void, Rawmessage_47557)(NU8 Msg_47559, NimStringDesc** Args_47561, NI Args_47561Len0);
N_NIMCALL(TY47532, Unknownlineinfo_47536)(void);
N_NIMCALL(NimStringDesc*, nsuFormatSingleElem)(NimStringDesc* Formatstr_24972, NimStringDesc* A_24973);
N_NIMCALL(void, Rawmessage_47553)(NU8 Msg_47555, NimStringDesc* Arg_47556);
N_NIMCALL(void, Writeln_47841)(FILE* F_47844, NimStringDesc* X_47845);
N_NIMCALL(void, Write_3658)(FILE* F_3660, NimStringDesc* S_3661);
STRING_LITERAL(TMP47242, "unknown error", 13);
STRING_LITERAL(TMP47243, "illformed AST: $1", 17);
STRING_LITERAL(TMP47244, "cannot open \'$1\'", 16);
STRING_LITERAL(TMP47245, "internal error: $1", 18);
STRING_LITERAL(TMP47246, "$1", 2);
STRING_LITERAL(TMP47247, "\'$1\' compiler does not support C++", 34);
STRING_LITERAL(TMP47248, "string literal expected", 23);
STRING_LITERAL(TMP47249, "integer literal expected", 24);
STRING_LITERAL(TMP47250, "invalid character constant", 26);
STRING_LITERAL(TMP47251, "closing \"\"\" expected, but end of file reached", 45);
STRING_LITERAL(TMP47252, "closing \" expected", 18);
STRING_LITERAL(TMP47253, "tabulators are not allowed", 26);
STRING_LITERAL(TMP47254, "invalid token: $1", 17);
STRING_LITERAL(TMP47255, "line too long", 13);
STRING_LITERAL(TMP47256, "$1 is not a valid number", 24);
STRING_LITERAL(TMP47257, "number $1 out of valid range", 28);
STRING_LITERAL(TMP47258, "\\n not allowed in character literal", 35);
STRING_LITERAL(TMP47259, "closing \']\' expected, but end of file reached", 45);
STRING_LITERAL(TMP47260, "missing final \'", 15);
STRING_LITERAL(TMP47261, "identifier expected, but found \'$1\'", 35);
STRING_LITERAL(TMP47262, "operator expected, but found \'$1\'", 33);
STRING_LITERAL(TMP47263, "\'$1\' expected", 13);
STRING_LITERAL(TMP47264, "string after \'include\' expected", 31);
STRING_LITERAL(TMP47265, "recursive dependency: \'$1\'", 26);
STRING_LITERAL(TMP47266, "\'on\' or \'off\' expected", 22);
STRING_LITERAL(TMP47267, "\'none\', \'speed\' or \'size\' expected", 34);
STRING_LITERAL(TMP47268, "invalid pragma", 14);
STRING_LITERAL(TMP47269, "unknown pragma: \'$1\'", 20);
STRING_LITERAL(TMP47270, "invalid directive: \'$1\'", 23);
STRING_LITERAL(TMP47271, "\'pop\' without a \'push\' pragma", 29);
STRING_LITERAL(TMP47272, "empty asm statement", 19);
STRING_LITERAL(TMP47273, "invalid indentation", 19);
STRING_LITERAL(TMP47274, "exception expected", 18);
STRING_LITERAL(TMP47275, "exception already handled", 25);
STRING_LITERAL(TMP47276, "\'yield\' only allowed in a loop of an iterator", 45);
STRING_LITERAL(TMP47277, "invalid number of \'yield\' expresions", 36);
STRING_LITERAL(TMP47278, "current routine cannot return an expression", 43);
STRING_LITERAL(TMP47279, "attempt to redefine \'$1\'", 24);
STRING_LITERAL(TMP47280, "statement not allowed after \'return\', \'break\' or \'raise\'", 56);
STRING_LITERAL(TMP47281, "statement expected", 18);
STRING_LITERAL(TMP47282, "\'$1\' is no label", 16);
STRING_LITERAL(TMP47283, "invalid command line option: \'$1\'", 33);
STRING_LITERAL(TMP47284, "argument for command line option expected: \'$1\'", 47);
STRING_LITERAL(TMP47285, "invalid argument for command line option: \'$1\'", 46);
STRING_LITERAL(TMP47286, "invalid variable substitution in \'$1\'", 37);
STRING_LITERAL(TMP47287, "unknown variable: \'$1\'", 22);
STRING_LITERAL(TMP47288, "unknown C compiler: \'$1\'", 24);
STRING_LITERAL(TMP47289, "\'on\' or \'off\' expected, but \'$1\' found", 38);
STRING_LITERAL(TMP47290, "\'none\', \'boehm\' or \'refc\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP47291, "\'none\', \'speed\' or \'size\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP47292, "\'gui\', \'console\' or \'lib\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP47293, "unknown OS: \'$1\'", 16);
STRING_LITERAL(TMP47294, "unknown CPU: \'$1\'", 17);
STRING_LITERAL(TMP47295, "\'c\', \'c++\' or \'yaml\' expected, but \'$1\' found", 45);
STRING_LITERAL(TMP47296, "arguments can only be given if the \'--run\' option is selected", 61);
STRING_LITERAL(TMP47297, "multiple assignment is not allowed", 34);
STRING_LITERAL(TMP47298, "\':\' or \'=\' expected, but found \'$1\'", 35);
STRING_LITERAL(TMP47299, "expression expected, but found \'$1\'", 35);
STRING_LITERAL(TMP47300, "undeclared identifier: \'$1\'", 27);
STRING_LITERAL(TMP47301, "ambiguous identifier: \'$1\' -- use a qualifier", 45);
STRING_LITERAL(TMP47302, "type expected", 13);
STRING_LITERAL(TMP47303, "system module needs \'$1\'", 24);
STRING_LITERAL(TMP47304, "execution of an external program failed", 39);
STRING_LITERAL(TMP47305, "overloaded \'$1\' leads to ambiguous calls", 40);
STRING_LITERAL(TMP47306, "invalid argument for \'$1\'", 25);
STRING_LITERAL(TMP47307, "statement has no effect", 23);
STRING_LITERAL(TMP47308, "\'$1\' expects a type or value", 28);
STRING_LITERAL(TMP47309, "\'$1\' expects an array type", 26);
STRING_LITERAL(TMP47310, "\'$1\' cannot be instantiated because its body has not been compi"
"led yet", 70);
STRING_LITERAL(TMP47311, "expression \'$1\' ambiguous in this context", 41);
STRING_LITERAL(TMP47312, "constant division by zero", 25);
STRING_LITERAL(TMP47313, "ordinal type expected", 21);
STRING_LITERAL(TMP47314, "ordinal or float type expected", 30);
STRING_LITERAL(TMP47315, "over- or underflow", 18);
STRING_LITERAL(TMP47316, "cannot evalutate \'$1\' because type is not defined completely", 60);
STRING_LITERAL(TMP47317, "\'chr\' expects an int in the range 0..255", 40);
STRING_LITERAL(TMP47318, "\'dynlib\' requires \'exportc\'", 27);
STRING_LITERAL(TMP47319, "undeclared field: \'$1\'", 22);
STRING_LITERAL(TMP47320, "attempt to access a nil address", 31);
STRING_LITERAL(TMP47321, "index out of bounds", 19);
STRING_LITERAL(TMP47322, "index types do not match", 24);
STRING_LITERAL(TMP47323, "\'[]\' operator invalid for this type", 35);
STRING_LITERAL(TMP47324, "value out of set bounds", 23);
STRING_LITERAL(TMP47325, "field initialized twice: \'$1\'", 29);
STRING_LITERAL(TMP47326, "field \'$1\' not initialized", 26);
STRING_LITERAL(TMP47327, "expression \'$1\' cannot be called", 32);
STRING_LITERAL(TMP47328, "expression has no type", 22);
STRING_LITERAL(TMP47329, "expression \'$1\' has no type (or is ambiguous)", 45);
STRING_LITERAL(TMP47330, "\'cast\' not allowed in safe mode", 31);
STRING_LITERAL(TMP47331, "expression cannot be casted to $1", 33);
STRING_LITERAL(TMP47332, "\',\' or \')\' expected", 19);
STRING_LITERAL(TMP47333, "\'{\' or \'(\' expected", 19);
STRING_LITERAL(TMP47334, "section (\'type\', \'proc\', etc.) expected", 39);
STRING_LITERAL(TMP47335, "range expected", 14);
STRING_LITERAL(TMP47336, "\'magic\' only allowed in system module", 37);
STRING_LITERAL(TMP47337, "power of two expected", 21);
STRING_LITERAL(TMP47338, "string literal may not be empty", 31);
STRING_LITERAL(TMP47339, "calling convention expected", 27);
STRING_LITERAL(TMP47340, "a proc can only have one calling convention", 43);
STRING_LITERAL(TMP47341, "symbol must be imported if \'lib\' pragma is used", 47);
STRING_LITERAL(TMP47342, "expression must be of type \'bool\'", 33);
STRING_LITERAL(TMP47343, "constant expression expected", 28);
STRING_LITERAL(TMP47344, "duplicate case label", 20);
STRING_LITERAL(TMP47345, "range is empty", 14);
STRING_LITERAL(TMP47346, "selector must be of an ordinal type, real or string", 51);
STRING_LITERAL(TMP47347, "selector must be of an ordinal type", 35);
STRING_LITERAL(TMP47348, "ord($1) must not be negative", 28);
STRING_LITERAL(TMP47349, "len($1) must be less than 32768", 31);
STRING_LITERAL(TMP47350, "wrong number of variables", 25);
STRING_LITERAL(TMP47351, "only objects can be raised", 26);
STRING_LITERAL(TMP47352, "\'break\' only allowed in loop construct", 38);
STRING_LITERAL(TMP47353, "type \'$1\' has unknown size", 26);
STRING_LITERAL(TMP47354, "a constant can only be initialized with a constant expression", 61);
STRING_LITERAL(TMP47355, "a constant needs a value", 24);
STRING_LITERAL(TMP47356, "the result type cannot be on open array", 39);
STRING_LITERAL(TMP47357, "computing the type\'s size produced an overflow", 46);
STRING_LITERAL(TMP47358, "set is too large", 16);
STRING_LITERAL(TMP47359, "base type of a set must be an ordinal", 37);
STRING_LITERAL(TMP47360, "inheritance only works with non-final objects", 45);
STRING_LITERAL(TMP47361, "inheritance only works with an enum", 35);
STRING_LITERAL(TMP47362, "illegal recursion in type \'$1\'", 30);
STRING_LITERAL(TMP47363, "cannot instantiate: \'$1\'", 24);
STRING_LITERAL(TMP47364, "expression has no address", 25);
STRING_LITERAL(TMP47365, "for a \'var\' type a variable needs to be passed", 46);
STRING_LITERAL(TMP47366, "type mismatch", 13);
STRING_LITERAL(TMP47367, "type mismatch: got (", 20);
STRING_LITERAL(TMP47368, "but expected one of: ", 21);
STRING_LITERAL(TMP47369, "but expected \'$1\'", 17);
STRING_LITERAL(TMP47370, "ambiguous call; both $1 and $2 match for: $3", 44);
STRING_LITERAL(TMP47371, "wrong number of arguments", 25);
STRING_LITERAL(TMP47372, "\'$1\' cannot be passed to a procvar", 34);
STRING_LITERAL(TMP47373, "$1 cannot be declared in parameter declaration", 46);
STRING_LITERAL(TMP47374, "pragmas are only in the header of a proc allowed", 48);
STRING_LITERAL(TMP47375, "implementation of \'$1\' is not allowed", 37);
STRING_LITERAL(TMP47376, "implementation of \'$1\' expected", 31);
STRING_LITERAL(TMP47377, "no symbol to borrow from found", 30);
STRING_LITERAL(TMP47378, "value returned by statement has to be discarded", 47);
STRING_LITERAL(TMP47379, "statement returns no value that can be discarded", 48);
STRING_LITERAL(TMP47380, "conversion from $1 to $2 is invalid", 35);
STRING_LITERAL(TMP47381, "cannot bind parameter \'$1\' twice", 32);
STRING_LITERAL(TMP47382, "invalid order in enum \'$1\'", 26);
STRING_LITERAL(TMP47383, "enum \'$1\' has wholes", 20);
STRING_LITERAL(TMP47384, "\'except\' or \'finally\' expected", 30);
STRING_LITERAL(TMP47385, "after catch all \'except\' or \'finally\' no section may follow", 59);
STRING_LITERAL(TMP47386, "option expected, but found \'$1\'", 31);
STRING_LITERAL(TMP47387, "\'$1\' is not a label", 19);
STRING_LITERAL(TMP47388, "not all cases are covered", 25);
STRING_LITERAL(TMP47389, "unknown substitution variable: \'$1\'", 35);
STRING_LITERAL(TMP47390, "complex statement requires indentation", 38);
STRING_LITERAL(TMP47391, "\'$1\' is not callable", 20);
STRING_LITERAL(TMP47392, "no pragmas allowed for $1", 25);
STRING_LITERAL(TMP47393, "no generic parameters allowed for $1", 36);
STRING_LITERAL(TMP47394, "invalid param kind: \'$1\'", 24);
STRING_LITERAL(TMP47395, "default argument invalid", 24);
STRING_LITERAL(TMP47396, "named parameter has to be an identifier", 39);
STRING_LITERAL(TMP47397, "no return type for $1 allowed", 29);
STRING_LITERAL(TMP47398, "a type conversion needs exactly one argument", 44);
STRING_LITERAL(TMP47399, "invalid pragma: $1", 18);
STRING_LITERAL(TMP47400, "$1 not allowed here", 19);
STRING_LITERAL(TMP47401, "invalid control flow: $1", 24);
STRING_LITERAL(TMP47402, "a type has no value", 19);
STRING_LITERAL(TMP47403, "invalid type: \'$1\'", 18);
STRING_LITERAL(TMP47404, "\'^\' needs a pointer or reference type", 37);
STRING_LITERAL(TMP47405, "invalid expression", 18);
STRING_LITERAL(TMP47406, "invalid expression: \'$1\'", 24);
STRING_LITERAL(TMP47407, "enum has no value \'$1\'", 22);
STRING_LITERAL(TMP47408, "named expression expected", 25);
STRING_LITERAL(TMP47409, "named expression not allowed here", 33);
STRING_LITERAL(TMP47410, "\'$1\' expects one type parameter", 31);
STRING_LITERAL(TMP47411, "array expects two type parameters", 33);
STRING_LITERAL(TMP47412, "invalid visibility: \'$1\'", 24);
STRING_LITERAL(TMP47413, "initialization not allowed here", 31);
STRING_LITERAL(TMP47414, "\'$1\' cannot be assigned to", 26);
STRING_LITERAL(TMP47415, "iterators can only be defined at the module\'s top level", 55);
STRING_LITERAL(TMP47416, "$1 needs a return type", 22);
STRING_LITERAL(TMP47417, "invalid command: \'$1\'", 21);
STRING_LITERAL(TMP47418, "\'$1\' is only allowed at top level", 33);
STRING_LITERAL(TMP47419, "template/macro instantiation too nested", 39);
STRING_LITERAL(TMP47420, "instantiation from here", 23);
STRING_LITERAL(TMP47421, "invalid index value for tuple subscript", 39);
STRING_LITERAL(TMP47422, "command expects a filename argument", 35);
STRING_LITERAL(TMP47423, "invalid section start", 21);
STRING_LITERAL(TMP47424, "grid table is not implemented", 29);
STRING_LITERAL(TMP47425, "general parse error", 19);
STRING_LITERAL(TMP47426, "new section expected", 20);
STRING_LITERAL(TMP47427, "whitespace expected, got \'$1\'", 29);
STRING_LITERAL(TMP47428, "\'$1\' is no valid index file", 27);
STRING_LITERAL(TMP47429, "cannot render reStructuredText element \'$1\'", 43);
STRING_LITERAL(TMP47430, "type \'var var\' is not allowed", 29);
STRING_LITERAL(TMP47431, "\'is\' expects two arguments", 26);
STRING_LITERAL(TMP47432, "\'is\' expects object types", 25);
STRING_LITERAL(TMP47433, "\'$1\' can never be of this subtype", 33);
STRING_LITERAL(TMP47434, "interpretation requires too many iterations", 43);
STRING_LITERAL(TMP47435, "cannot interpret node kind \'$1\'", 31);
STRING_LITERAL(TMP47436, "field \'$1\' cannot be found", 26);
STRING_LITERAL(TMP47437, "invalid conversion from type \'$1\'", 33);
STRING_LITERAL(TMP47438, "assertion failed", 16);
STRING_LITERAL(TMP47439, "cannot generate code for \'$1\'", 29);
STRING_LITERAL(TMP47440, "$1 requires one parameter", 25);
STRING_LITERAL(TMP47441, "unhandled exception: $1", 23);
STRING_LITERAL(TMP47442, "macro returned a cyclic abstract syntax tree", 44);
STRING_LITERAL(TMP47443, "\'$1\' is no macro or template", 28);
STRING_LITERAL(TMP47444, "\'$1\' can have side effects", 26);
STRING_LITERAL(TMP47445, "iterator within for loop context expected", 41);
STRING_LITERAL(TMP47446, "cannot open \'$1\' [CannotOpenFile]", 33);
STRING_LITERAL(TMP47447, "octal escape sequences do not exist; leading zero is ignored [O"
"ctalEscape]", 74);
STRING_LITERAL(TMP47448, "\'$1\' is never read [XIsNeverRead]", 33);
STRING_LITERAL(TMP47449, "\'$1\' might not have been initialized [XmightNotBeenInit]", 56);
STRING_LITERAL(TMP47450, "cannot write file \'$1\' [CannotWriteMO2]", 39);
STRING_LITERAL(TMP47451, "cannot read file \'$1\' [CannotReadMO2]", 37);
STRING_LITERAL(TMP47452, "\'$1\' is deprecated [Deprecated]", 31);
STRING_LITERAL(TMP47453, "\'l\' should not be used as an identifier; may look like \'1\' (one"
") [SmallLshouldNotBeUsed]", 88);
STRING_LITERAL(TMP47454, "unknown magic \'$1\' might crash the compiler [UnknownMagic]", 58);
STRING_LITERAL(TMP47455, "redefinition of label \'$1\' [RedefinitionOfLabel]", 48);
STRING_LITERAL(TMP47456, "unknown substitution \'$1\' [UnknownSubstitutionX]", 48);
STRING_LITERAL(TMP47457, "language \'$1\' not supported [LanguageXNotSupported]", 51);
STRING_LITERAL(TMP47458, "comment \'$1\' ignored [CommentXIgnored]", 38);
STRING_LITERAL(TMP47459, "\'$1\' is passed to a procvar; deprecated [XisPassedToProcVar]", 60);
STRING_LITERAL(TMP47460, "$1 [User]", 9);
STRING_LITERAL(TMP47461, "operation successful [Success]", 30);
STRING_LITERAL(TMP47462, "operation successful ($1 lines compiled; $2 sec total) [Success"
"X]", 65);
STRING_LITERAL(TMP47463, "line too long [LineTooLong]", 27);
STRING_LITERAL(TMP47464, "\'$1\' is declared but not used [XDeclaredButNotUsed]", 51);
STRING_LITERAL(TMP47465, "conversion to base object is not needed [ConvToBaseNotNeeded]", 61);
STRING_LITERAL(TMP47466, "conversion from $1 to itself is pointless [ConvFromXtoItselfNot"
"Needed]", 70);
STRING_LITERAL(TMP47467, "expression evaluates always to \'$1\' [ExprAlwaysX]", 49);
STRING_LITERAL(TMP47468, "quit() called [QuitCalled]", 26);
STRING_LITERAL(TMP47469, "$1 [Processing]", 15);
STRING_LITERAL(TMP47470, "generated code listing: [CodeBegin]", 35);
STRING_LITERAL(TMP47471, "end of listing [CodeEnd]", 24);
STRING_LITERAL(TMP47472, "used config file \'$1\' [Conf]", 28);
NIM_CONST TY47239 Msgkindtostr_47238 = {((NimStringDesc*) &TMP47242),
((NimStringDesc*) &TMP47243),
((NimStringDesc*) &TMP47244),
((NimStringDesc*) &TMP47245),
((NimStringDesc*) &TMP47246),
((NimStringDesc*) &TMP47247),
((NimStringDesc*) &TMP47248),
((NimStringDesc*) &TMP47249),
((NimStringDesc*) &TMP47250),
((NimStringDesc*) &TMP47251),
((NimStringDesc*) &TMP47252),
((NimStringDesc*) &TMP47253),
((NimStringDesc*) &TMP47254),
((NimStringDesc*) &TMP47255),
((NimStringDesc*) &TMP47256),
((NimStringDesc*) &TMP47257),
((NimStringDesc*) &TMP47258),
((NimStringDesc*) &TMP47259),
((NimStringDesc*) &TMP47260),
((NimStringDesc*) &TMP47261),
((NimStringDesc*) &TMP47262),
((NimStringDesc*) &TMP47263),
((NimStringDesc*) &TMP47264),
((NimStringDesc*) &TMP47265),
((NimStringDesc*) &TMP47266),
((NimStringDesc*) &TMP47267),
((NimStringDesc*) &TMP47268),
((NimStringDesc*) &TMP47269),
((NimStringDesc*) &TMP47270),
((NimStringDesc*) &TMP47271),
((NimStringDesc*) &TMP47272),
((NimStringDesc*) &TMP47273),
((NimStringDesc*) &TMP47274),
((NimStringDesc*) &TMP47275),
((NimStringDesc*) &TMP47276),
((NimStringDesc*) &TMP47277),
((NimStringDesc*) &TMP47278),
((NimStringDesc*) &TMP47279),
((NimStringDesc*) &TMP47280),
((NimStringDesc*) &TMP47281),
((NimStringDesc*) &TMP47282),
((NimStringDesc*) &TMP47283),
((NimStringDesc*) &TMP47284),
((NimStringDesc*) &TMP47285),
((NimStringDesc*) &TMP47286),
((NimStringDesc*) &TMP47287),
((NimStringDesc*) &TMP47288),
((NimStringDesc*) &TMP47289),
((NimStringDesc*) &TMP47290),
((NimStringDesc*) &TMP47291),
((NimStringDesc*) &TMP47292),
((NimStringDesc*) &TMP47293),
((NimStringDesc*) &TMP47294),
((NimStringDesc*) &TMP47295),
((NimStringDesc*) &TMP47296),
((NimStringDesc*) &TMP47297),
((NimStringDesc*) &TMP47298),
((NimStringDesc*) &TMP47299),
((NimStringDesc*) &TMP47300),
((NimStringDesc*) &TMP47301),
((NimStringDesc*) &TMP47302),
((NimStringDesc*) &TMP47303),
((NimStringDesc*) &TMP47304),
((NimStringDesc*) &TMP47305),
((NimStringDesc*) &TMP47306),
((NimStringDesc*) &TMP47307),
((NimStringDesc*) &TMP47308),
((NimStringDesc*) &TMP47309),
((NimStringDesc*) &TMP47310),
((NimStringDesc*) &TMP47311),
((NimStringDesc*) &TMP47312),
((NimStringDesc*) &TMP47313),
((NimStringDesc*) &TMP47314),
((NimStringDesc*) &TMP47315),
((NimStringDesc*) &TMP47316),
((NimStringDesc*) &TMP47317),
((NimStringDesc*) &TMP47318),
((NimStringDesc*) &TMP47319),
((NimStringDesc*) &TMP47320),
((NimStringDesc*) &TMP47321),
((NimStringDesc*) &TMP47322),
((NimStringDesc*) &TMP47323),
((NimStringDesc*) &TMP47324),
((NimStringDesc*) &TMP47325),
((NimStringDesc*) &TMP47326),
((NimStringDesc*) &TMP47327),
((NimStringDesc*) &TMP47328),
((NimStringDesc*) &TMP47329),
((NimStringDesc*) &TMP47330),
((NimStringDesc*) &TMP47331),
((NimStringDesc*) &TMP47332),
((NimStringDesc*) &TMP47333),
((NimStringDesc*) &TMP47334),
((NimStringDesc*) &TMP47335),
((NimStringDesc*) &TMP47279),
((NimStringDesc*) &TMP47336),
((NimStringDesc*) &TMP47337),
((NimStringDesc*) &TMP47338),
((NimStringDesc*) &TMP47339),
((NimStringDesc*) &TMP47340),
((NimStringDesc*) &TMP47341),
((NimStringDesc*) &TMP47342),
((NimStringDesc*) &TMP47343),
((NimStringDesc*) &TMP47344),
((NimStringDesc*) &TMP47345),
((NimStringDesc*) &TMP47346),
((NimStringDesc*) &TMP47347),
((NimStringDesc*) &TMP47348),
((NimStringDesc*) &TMP47349),
((NimStringDesc*) &TMP47350),
((NimStringDesc*) &TMP47351),
((NimStringDesc*) &TMP47352),
((NimStringDesc*) &TMP47353),
((NimStringDesc*) &TMP47354),
((NimStringDesc*) &TMP47355),
((NimStringDesc*) &TMP47356),
((NimStringDesc*) &TMP47357),
((NimStringDesc*) &TMP47358),
((NimStringDesc*) &TMP47359),
((NimStringDesc*) &TMP47360),
((NimStringDesc*) &TMP47361),
((NimStringDesc*) &TMP47362),
((NimStringDesc*) &TMP47363),
((NimStringDesc*) &TMP47364),
((NimStringDesc*) &TMP47365),
((NimStringDesc*) &TMP47366),
((NimStringDesc*) &TMP47367),
((NimStringDesc*) &TMP47368),
((NimStringDesc*) &TMP47369),
((NimStringDesc*) &TMP47370),
((NimStringDesc*) &TMP47371),
((NimStringDesc*) &TMP47372),
((NimStringDesc*) &TMP47373),
((NimStringDesc*) &TMP47374),
((NimStringDesc*) &TMP47375),
((NimStringDesc*) &TMP47376),
((NimStringDesc*) &TMP47377),
((NimStringDesc*) &TMP47378),
((NimStringDesc*) &TMP47379),
((NimStringDesc*) &TMP47380),
((NimStringDesc*) &TMP47381),
((NimStringDesc*) &TMP47382),
((NimStringDesc*) &TMP47383),
((NimStringDesc*) &TMP47384),
((NimStringDesc*) &TMP47385),
((NimStringDesc*) &TMP47386),
((NimStringDesc*) &TMP47387),
((NimStringDesc*) &TMP47388),
((NimStringDesc*) &TMP47389),
((NimStringDesc*) &TMP47390),
((NimStringDesc*) &TMP47391),
((NimStringDesc*) &TMP47392),
((NimStringDesc*) &TMP47393),
((NimStringDesc*) &TMP47394),
((NimStringDesc*) &TMP47395),
((NimStringDesc*) &TMP47396),
((NimStringDesc*) &TMP47397),
((NimStringDesc*) &TMP47398),
((NimStringDesc*) &TMP47399),
((NimStringDesc*) &TMP47400),
((NimStringDesc*) &TMP47401),
((NimStringDesc*) &TMP47402),
((NimStringDesc*) &TMP47403),
((NimStringDesc*) &TMP47404),
((NimStringDesc*) &TMP47405),
((NimStringDesc*) &TMP47406),
((NimStringDesc*) &TMP47407),
((NimStringDesc*) &TMP47408),
((NimStringDesc*) &TMP47409),
((NimStringDesc*) &TMP47410),
((NimStringDesc*) &TMP47411),
((NimStringDesc*) &TMP47412),
((NimStringDesc*) &TMP47413),
((NimStringDesc*) &TMP47414),
((NimStringDesc*) &TMP47415),
((NimStringDesc*) &TMP47416),
((NimStringDesc*) &TMP47417),
((NimStringDesc*) &TMP47418),
((NimStringDesc*) &TMP47419),
((NimStringDesc*) &TMP47420),
((NimStringDesc*) &TMP47421),
((NimStringDesc*) &TMP47422),
((NimStringDesc*) &TMP47263),
((NimStringDesc*) &TMP47423),
((NimStringDesc*) &TMP47424),
((NimStringDesc*) &TMP47425),
((NimStringDesc*) &TMP47426),
((NimStringDesc*) &TMP47427),
((NimStringDesc*) &TMP47428),
((NimStringDesc*) &TMP47429),
((NimStringDesc*) &TMP47430),
((NimStringDesc*) &TMP47431),
((NimStringDesc*) &TMP47432),
((NimStringDesc*) &TMP47433),
((NimStringDesc*) &TMP47434),
((NimStringDesc*) &TMP47435),
((NimStringDesc*) &TMP47436),
((NimStringDesc*) &TMP47437),
((NimStringDesc*) &TMP47438),
((NimStringDesc*) &TMP47439),
((NimStringDesc*) &TMP47440),
((NimStringDesc*) &TMP47441),
((NimStringDesc*) &TMP47442),
((NimStringDesc*) &TMP47443),
((NimStringDesc*) &TMP47444),
((NimStringDesc*) &TMP47445),
((NimStringDesc*) &TMP47246),
((NimStringDesc*) &TMP47446),
((NimStringDesc*) &TMP47447),
((NimStringDesc*) &TMP47448),
((NimStringDesc*) &TMP47449),
((NimStringDesc*) &TMP47450),
((NimStringDesc*) &TMP47451),
((NimStringDesc*) &TMP47452),
((NimStringDesc*) &TMP47453),
((NimStringDesc*) &TMP47454),
((NimStringDesc*) &TMP47455),
((NimStringDesc*) &TMP47456),
((NimStringDesc*) &TMP47457),
((NimStringDesc*) &TMP47458),
((NimStringDesc*) &TMP47459),
((NimStringDesc*) &TMP47460),
((NimStringDesc*) &TMP47461),
((NimStringDesc*) &TMP47462),
((NimStringDesc*) &TMP47463),
((NimStringDesc*) &TMP47464),
((NimStringDesc*) &TMP47465),
((NimStringDesc*) &TMP47466),
((NimStringDesc*) &TMP47467),
((NimStringDesc*) &TMP47468),
((NimStringDesc*) &TMP47469),
((NimStringDesc*) &TMP47470),
((NimStringDesc*) &TMP47471),
((NimStringDesc*) &TMP47472),
((NimStringDesc*) &TMP47460)}
;
STRING_LITERAL(TMP47478, "CannotOpenFile", 14);
STRING_LITERAL(TMP47479, "OctalEscape", 11);
STRING_LITERAL(TMP47480, "XIsNeverRead", 12);
STRING_LITERAL(TMP47481, "XmightNotBeenInit", 17);
STRING_LITERAL(TMP47482, "CannotWriteMO2", 14);
STRING_LITERAL(TMP47483, "CannotReadMO2", 13);
STRING_LITERAL(TMP47484, "Deprecated", 10);
STRING_LITERAL(TMP47485, "SmallLshouldNotBeUsed", 21);
STRING_LITERAL(TMP47486, "UnknownMagic", 12);
STRING_LITERAL(TMP47487, "RedefinitionOfLabel", 19);
STRING_LITERAL(TMP47488, "UnknownSubstitutionX", 20);
STRING_LITERAL(TMP47489, "LanguageXNotSupported", 21);
STRING_LITERAL(TMP47490, "CommentXIgnored", 15);
STRING_LITERAL(TMP47491, "XisPassedToProcVar", 18);
STRING_LITERAL(TMP47492, "User", 4);
NIM_CONST TY47474 Warningstostr_47473 = {((NimStringDesc*) &TMP47478),
((NimStringDesc*) &TMP47479),
((NimStringDesc*) &TMP47480),
((NimStringDesc*) &TMP47481),
((NimStringDesc*) &TMP47482),
((NimStringDesc*) &TMP47483),
((NimStringDesc*) &TMP47484),
((NimStringDesc*) &TMP47485),
((NimStringDesc*) &TMP47486),
((NimStringDesc*) &TMP47487),
((NimStringDesc*) &TMP47488),
((NimStringDesc*) &TMP47489),
((NimStringDesc*) &TMP47490),
((NimStringDesc*) &TMP47491),
((NimStringDesc*) &TMP47492)}
;
STRING_LITERAL(TMP47498, "Success", 7);
STRING_LITERAL(TMP47499, "SuccessX", 8);
STRING_LITERAL(TMP47500, "LineTooLong", 11);
STRING_LITERAL(TMP47501, "XDeclaredButNotUsed", 19);
STRING_LITERAL(TMP47502, "ConvToBaseNotNeeded", 19);
STRING_LITERAL(TMP47503, "ConvFromXtoItselfNotNeeded", 26);
STRING_LITERAL(TMP47504, "ExprAlwaysX", 11);
STRING_LITERAL(TMP47505, "QuitCalled", 10);
STRING_LITERAL(TMP47506, "Processing", 10);
STRING_LITERAL(TMP47507, "CodeBegin", 9);
STRING_LITERAL(TMP47508, "CodeEnd", 7);
STRING_LITERAL(TMP47509, "Conf", 4);
NIM_CONST TY47494 Hintstostr_47493 = {((NimStringDesc*) &TMP47498),
((NimStringDesc*) &TMP47499),
((NimStringDesc*) &TMP47500),
((NimStringDesc*) &TMP47501),
((NimStringDesc*) &TMP47502),
((NimStringDesc*) &TMP47503),
((NimStringDesc*) &TMP47504),
((NimStringDesc*) &TMP47505),
((NimStringDesc*) &TMP47506),
((NimStringDesc*) &TMP47507),
((NimStringDesc*) &TMP47508),
((NimStringDesc*) &TMP47509),
((NimStringDesc*) &TMP47492)}
;
STRING_LITERAL(TMP196616, "$1($2, $3) Error: $4", 20);
STRING_LITERAL(TMP196617, "???", 3);
STRING_LITERAL(TMP196618, "", 0);
STRING_LITERAL(TMP196619, "$1($2, $3) Warning: $4", 22);
STRING_LITERAL(TMP196620, "$1($2, $3) Hint: $4", 19);
STRING_LITERAL(TMP196676, "Error: $1", 9);
STRING_LITERAL(TMP196677, "Warning: $1", 11);
STRING_LITERAL(TMP196678, "Hint: $1", 8);
STRING_LITERAL(TMP197254, "$1($2, $3) Checkpoint: ", 23);
STRING_LITERAL(TMP198501, "\012", 1);
NU32 Gnotes_47539;
NI Gerrorcounter_47540;
NI Ghintcounter_47541;
NI Gwarncounter_47542;
NI Gerrormax_47543;
TY39422* Filenames_47634;
extern TNimType* NTI39422; /* seq[string] */
extern TY11190 Gch_11210;
TY47635* Msgcontext_47652;
extern TNimType* NTI47635; /* seq[TLineInfo] */
TY47635* Checkpoints_47784;
extern NU32 Goptions_46075;
extern NI Gverbosity_46083;
static N_INLINE(TY10802*, Usrtocell_11612)(void* Usr_11614) {
TY10802* Result_11615;
Result_11615 = 0;
Result_11615 = ((TY10802*) ((NI64)((NU64)(((NI) (Usr_11614))) - (NU64)(((NI) (((NI)sizeof(TY10802))))))));
return Result_11615;
}
static N_INLINE(NI, Atomicinc_3001)(NI* Memloc_3004, NI X_3005) {
NI Result_7607;
Result_7607 = 0;
(*Memloc_3004) += X_3005;
Result_7607 = (*Memloc_3004);
return Result_7607;
}
static N_INLINE(NI, Atomicdec_3006)(NI* Memloc_3009, NI X_3010) {
NI Result_7806;
Result_7806 = 0;
(*Memloc_3009) -= X_3010;
Result_7806 = (*Memloc_3009);
return Result_7806;
}
static N_INLINE(void, Rtladdzct_12601)(TY10802* C_12603) {
Addzct_11601(&Gch_11210.Zct, C_12603);
}
static N_INLINE(void, asgnRefNoCycle)(void** Dest_13218, void* Src_13219) {
TY10802* C_13220;
NI LOC4;
TY10802* C_13222;
NI LOC9;
if (!!((Src_13219 == NIM_NIL))) goto LA2;
C_13220 = 0;
C_13220 = Usrtocell_11612(Src_13219);
LOC4 = Atomicinc_3001(&(*C_13220).Refcount, 8);
LA2: ;
if (!!(((*Dest_13218) == NIM_NIL))) goto LA6;
C_13222 = 0;
C_13222 = Usrtocell_11612((*Dest_13218));
LOC9 = Atomicdec_3006(&(*C_13222).Refcount, 8);
if (!((NU64)(LOC9) < (NU64)(8))) goto LA10;
Rtladdzct_12601(C_13222);
LA10: ;
LA6: ;
(*Dest_13218) = Src_13219;
}
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* A_18647, NimStringDesc* B_18648) {
NIM_BOOL Result_18649;
NIM_BOOL LOC5;
NIM_BOOL LOC9;
int LOC11;
Result_18649 = 0;
if (!(A_18647 == B_18648)) goto LA2;
Result_18649 = NIM_TRUE;
goto BeforeRet;
LA2: ;
LOC5 = (A_18647 == NIM_NIL);
if (LOC5) goto LA6;
LOC5 = (B_18648 == NIM_NIL);
LA6: ;
if (!LOC5) goto LA7;
Result_18649 = NIM_FALSE;
goto BeforeRet;
LA7: ;
LOC9 = ((*A_18647).Sup.len == (*B_18648).Sup.len);
if (!(LOC9)) goto LA10;
LOC11 = memcmp(((NCSTRING) ((*A_18647).data)), ((NCSTRING) ((*B_18648).data)), ((int) ((NI64)((*A_18647).Sup.len * 1))));
LOC9 = (LOC11 == ((NI32) 0));
LA10: ;
Result_18649 = LOC9;
goto BeforeRet;
BeforeRet: ;
return Result_18649;
}
N_NIMCALL(NI, Includefilename_47611)(NimStringDesc* F_47613) {
NI Result_47707;
NI I_47730;
NI HEX3Atmp_47754;
NI Res_47756;
Result_47707 = 0;
I_47730 = 0;
HEX3Atmp_47754 = 0;
HEX3Atmp_47754 = (Filenames_47634->Sup.len-1);
Res_47756 = 0;
Res_47756 = HEX3Atmp_47754;
while (1) {
if (!(0 <= Res_47756)) goto LA1;
I_47730 = Res_47756;
if (!eqStrings(Filenames_47634->data[I_47730], F_47613)) goto LA3;
Result_47707 = I_47730;
goto BeforeRet;
LA3: ;
Res_47756 -= 1;
} LA1: ;
Result_47707 = Filenames_47634->Sup.len;
Filenames_47634 = (TY39422*) setLengthSeq(&(Filenames_47634)->Sup, sizeof(NimStringDesc*), (NI64)(Result_47707 + 1));
asgnRefNoCycle((void**) &Filenames_47634->data[Result_47707], copyString(F_47613));
BeforeRet: ;
return Result_47707;
}
N_NIMCALL(TY47532, Newlineinfo_47574)(NimStringDesc* Filename_47576, NI Line_47577, NI Col_47578) {
TY47532 Result_47820;
NI LOC1;
memset((void*)&Result_47820, 0, sizeof(Result_47820));
LOC1 = Includefilename_47611(Filename_47576);
Result_47820.Fileindex = ((int) (LOC1));
Result_47820.Line = ((NI16) (Line_47577));
Result_47820.Col = ((NI16) (Col_47578));
return Result_47820;
}
N_NIMCALL(NIM_BOOL, Samelineinfo_47985)(TY47532 A_47987, TY47532 B_47988) {
NIM_BOOL Result_47989;
NIM_BOOL LOC1;
Result_47989 = 0;
LOC1 = (A_47987.Line == B_47988.Line);
if (!(LOC1)) goto LA2;
LOC1 = (A_47987.Fileindex == B_47988.Fileindex);
LA2: ;
Result_47989 = LOC1;
return Result_47989;
}
N_NIMCALL(void, Messageout_47550)(NimStringDesc* S_47552) {
Writeln_47841(stdout, S_47552);
}
N_NIMCALL(NimStringDesc*, Tofilename_47579)(TY47532 Info_47581) {
NimStringDesc* Result_47824;
Result_47824 = 0;
if (!(((NI) (Info_47581.Fileindex)) == -1)) goto LA2;
Result_47824 = copyString(((NimStringDesc*) &TMP196617));
goto LA1;
LA2: ;
Result_47824 = copyString(Filenames_47634->data[Info_47581.Fileindex]);
LA1: ;
return Result_47824;
}
N_NIMCALL(NimStringDesc*, Coordtostr_47846)(NI Coord_47848) {
NimStringDesc* Result_47849;
Result_47849 = 0;
if (!(Coord_47848 == -1)) goto LA2;
Result_47849 = copyString(((NimStringDesc*) &TMP196617));
goto LA1;
LA2: ;
Result_47849 = nimIntToStr(Coord_47848);
LA1: ;
return Result_47849;
}
N_NIMCALL(NimStringDesc*, Msgkindtostring_47588)(NU8 Kind_47590) {
NimStringDesc* Result_47857;
Result_47857 = 0;
Result_47857 = copyString(Msgkindtostr_47238[(Kind_47590)-0]);
return Result_47857;
}
N_NIMCALL(NimStringDesc*, Getmessagestr_47858)(NU8 Msg_47860, NimStringDesc* Arg_47861) {
NimStringDesc* Result_47862;
NimStringDesc* LOC1;
TY47865 LOC2;
Result_47862 = 0;
LOC1 = 0;
LOC1 = Msgkindtostring_47588(Msg_47860);
memset((void*)&LOC2, 0, sizeof(LOC2));
LOC2[0] = copyString(Arg_47861);
Result_47862 = nsuFormatOpenArray(LOC1, LOC2, 1);
return Result_47862;
}
N_NIMCALL(void, Writecontext_47994)(TY47532 Lastinfo_47996) {
TY47532 Info_47997;
NI I_48015;
NI HEX3Atmp_48021;
NI Res_48023;
NIM_BOOL LOC3;
NIM_BOOL LOC4;
NIM_BOOL LOC6;
TY48018 LOC9;
NimStringDesc* LOC10;
memset((void*)&Info_47997, 0, sizeof(Info_47997));
Info_47997 = Lastinfo_47996;
I_48015 = 0;
HEX3Atmp_48021 = 0;
HEX3Atmp_48021 = (NI64)(Msgcontext_47652->Sup.len - 1);
Res_48023 = 0;
Res_48023 = 0;
while (1) {
if (!(Res_48023 <= HEX3Atmp_48021)) goto LA1;
I_48015 = Res_48023;
LOC4 = Samelineinfo_47985(Msgcontext_47652->data[I_48015], Lastinfo_47996);
LOC3 = !(LOC4);
if (!(LOC3)) goto LA5;
LOC6 = Samelineinfo_47985(Msgcontext_47652->data[I_48015], Info_47997);
LOC3 = !(LOC6);
LA5: ;
if (!LOC3) goto LA7;
memset((void*)&LOC9, 0, sizeof(LOC9));
LOC9[0] = Tofilename_47579(Msgcontext_47652->data[I_48015]);
LOC9[1] = Coordtostr_47846(((NI) (Msgcontext_47652->data[I_48015].Line)));
LOC9[2] = Coordtostr_47846(((NI) (Msgcontext_47652->data[I_48015].Col)));
LOC9[3] = Getmessagestr_47858(((NU8) 179), ((NimStringDesc*) &TMP196618));
LOC10 = 0;
LOC10 = nsuFormatOpenArray(((NimStringDesc*) &TMP196616), LOC9, 4);
Messageout_47550(LOC10);
LA7: ;
Info_47997 = Msgcontext_47652->data[I_48015];
Res_48023 += 1;
} LA1: ;
}
N_NIMCALL(void, Handleerror_47919)(NU8 Msg_47921) {
NIM_BOOL LOC5;
NIM_BOOL LOC13;
if (!(Msg_47921 == ((NU8) 3))) goto LA2;
LA2: ;
LOC5 = (((NU8) 0) <= Msg_47921);
if (!(LOC5)) goto LA6;
LOC5 = (Msg_47921 <= ((NU8) 3));
LA6: ;
if (!LOC5) goto LA7;
if (!(3 <= Gverbosity_46083)) goto LA10;
LA10: ;
exit(1);
LA7: ;
LOC13 = (((NU8) 0) <= Msg_47921);
if (!(LOC13)) goto LA14;
LOC13 = (Msg_47921 <= ((NU8) 206));
LA14: ;
if (!LOC13) goto LA15;
Gerrorcounter_47540 += 1;
if (!(Gerrormax_47543 <= Gerrorcounter_47540)) goto LA18;
if (!(3 <= Gverbosity_46083)) goto LA21;
LA21: ;
exit(1);
LA18: ;
LA15: ;
}
N_NIMCALL(void, Limessage_47562)(TY47532 Info_47564, NU8 Msg_47565, NimStringDesc* Arg_47566) {
NimStringDesc* Frmt_48113;
TY48018 LOC13;
NimStringDesc* LOC14;
Frmt_48113 = 0;
switch (Msg_47565) {
case ((NU8) 0) ... ((NU8) 206):
Writecontext_47994(Info_47564);
Frmt_48113 = copyString(((NimStringDesc*) &TMP196616));
break;
case ((NU8) 207) ... ((NU8) 221):
if (!!(((Goptions_46075 &(1<<((((NU8) 11))&31)))!=0))) goto LA2;
goto BeforeRet;
LA2: ;
if (!!(((Gnotes_47539 &(1<<(((((NU8) (Msg_47565))-207))&31)))!=0))) goto LA5;
goto BeforeRet;
LA5: ;
Frmt_48113 = copyString(((NimStringDesc*) &TMP196619));
Gwarncounter_47542 += 1;
break;
case ((NU8) 222) ... ((NU8) 234):
if (!!(((Goptions_46075 &(1<<((((NU8) 12))&31)))!=0))) goto LA8;
goto BeforeRet;
LA8: ;
if (!!(((Gnotes_47539 &(1<<(((((NU8) (Msg_47565))-207))&31)))!=0))) goto LA11;
goto BeforeRet;
LA11: ;
Frmt_48113 = copyString(((NimStringDesc*) &TMP196620));
Ghintcounter_47541 += 1;
break;
default:
break;
}
memset((void*)&LOC13, 0, sizeof(LOC13));
LOC13[0] = Tofilename_47579(Info_47564);
LOC13[1] = Coordtostr_47846(((NI) (Info_47564.Line)));
LOC13[2] = Coordtostr_47846(((NI) (Info_47564.Col)));
LOC13[3] = Getmessagestr_47858(Msg_47565, Arg_47566);
LOC14 = 0;
LOC14 = nsuFormatOpenArray(Frmt_48113, LOC13, 4);
Messageout_47550(LOC14);
Handleerror_47919(Msg_47565);
BeforeRet: ;
}
N_NIMCALL(void, Internalerror_47567)(TY47532 Info_47569, NimStringDesc* Errmsg_47570) {
Writecontext_47994(Info_47569);
Limessage_47562(Info_47569, ((NU8) 3), Errmsg_47570);
}
N_NIMCALL(TY47532, Unknownlineinfo_47536)(void) {
TY47532 Result_47616;
memset((void*)&Result_47616, 0, sizeof(Result_47616));
Result_47616.Line = ((NI16) -1);
Result_47616.Col = ((NI16) -1);
Result_47616.Fileindex = ((NI32) -1);
return Result_47616;
}
N_NIMCALL(void, Rawmessage_47557)(NU8 Msg_47559, NimStringDesc** Args_47561, NI Args_47561Len0) {
NimStringDesc* Frmt_48031;
TY47532 LOC1;
NimStringDesc* LOC14;
NimStringDesc* LOC15;
NimStringDesc* LOC16;
Frmt_48031 = 0;
switch (Msg_47559) {
case ((NU8) 0) ... ((NU8) 206):
LOC1 = Unknownlineinfo_47536();
Writecontext_47994(LOC1);
Frmt_48031 = copyString(((NimStringDesc*) &TMP196676));
break;
case ((NU8) 207) ... ((NU8) 221):
if (!!(((Goptions_46075 &(1<<((((NU8) 11))&31)))!=0))) goto LA3;
goto BeforeRet;
LA3: ;
if (!!(((Gnotes_47539 &(1<<(((((NU8) (Msg_47559))-207))&31)))!=0))) goto LA6;
goto BeforeRet;
LA6: ;
Frmt_48031 = copyString(((NimStringDesc*) &TMP196677));
Gwarncounter_47542 += 1;
break;
case ((NU8) 222) ... ((NU8) 234):
if (!!(((Goptions_46075 &(1<<((((NU8) 12))&31)))!=0))) goto LA9;
goto BeforeRet;
LA9: ;
if (!!(((Gnotes_47539 &(1<<(((((NU8) (Msg_47559))-207))&31)))!=0))) goto LA12;
goto BeforeRet;
LA12: ;
Frmt_48031 = copyString(((NimStringDesc*) &TMP196678));
Ghintcounter_47541 += 1;
break;
default:
break;
}
LOC14 = 0;
LOC14 = Msgkindtostring_47588(Msg_47559);
LOC15 = 0;
LOC15 = nsuFormatOpenArray(LOC14, Args_47561, Args_47561Len0);
LOC16 = 0;
LOC16 = nsuFormatSingleElem(Frmt_48031, LOC15);
Messageout_47550(LOC16);
Handleerror_47919(Msg_47559);
BeforeRet: ;
}
N_NIMCALL(void, Rawmessage_47553)(NU8 Msg_47555, NimStringDesc* Arg_47556) {
TY47865 LOC1;
memset((void*)&LOC1, 0, sizeof(LOC1));
LOC1[0] = copyString(Arg_47556);
Rawmessage_47557(Msg_47555, LOC1, 1);
}
N_NIMCALL(void, Internalerror_47571)(NimStringDesc* Errmsg_47573) {
TY47532 LOC1;
LOC1 = Unknownlineinfo_47536();
Writecontext_47994(LOC1);
Rawmessage_47553(((NU8) 3), Errmsg_47573);
}
N_NIMCALL(NI, Tolinenumber_47585)(TY47532 Info_47587) {
NI Result_47830;
Result_47830 = 0;
Result_47830 = ((NI) (Info_47587.Line));
return Result_47830;
}
N_NIMCALL(void, Pushinfocontext_47606)(TY47532 Info_47608) {
NI Length_47657;
Length_47657 = 0;
Length_47657 = Msgcontext_47652->Sup.len;
Msgcontext_47652 = (TY47635*) setLengthSeq(&(Msgcontext_47652)->Sup, sizeof(TY47532), (NI64)(Length_47657 + 1));
Msgcontext_47652->data[Length_47657] = Info_47608;
}
N_NIMCALL(void, Popinfocontext_47609)(void) {
Msgcontext_47652 = (TY47635*) setLengthSeq(&(Msgcontext_47652)->Sup, sizeof(TY47532), (NI64)(Msgcontext_47652->Sup.len - 1));
}
N_NIMCALL(void, Addcheckpoint_47596)(TY47532 Info_47598) {
NI Length_47788;
Length_47788 = 0;
Length_47788 = Checkpoints_47784->Sup.len;
Checkpoints_47784 = (TY47635*) setLengthSeq(&(Checkpoints_47784)->Sup, sizeof(TY47532), (NI64)(Length_47788 + 1));
Checkpoints_47784->data[Length_47788] = Info_47598;
}
N_NIMCALL(NIM_BOOL, Incheckpoint_47603)(TY47532 Current_47605) {
NIM_BOOL Result_47870;
NI I_47904;
NI HEX3Atmp_47914;
NI Res_47916;
NIM_BOOL LOC6;
TY72066 LOC10;
NimStringDesc* LOC11;
Result_47870 = 0;
Result_47870 = NIM_FALSE;
if (!!(((Goptions_46075 &(1<<((((NU8) 19))&31)))!=0))) goto LA2;
goto BeforeRet;
LA2: ;
I_47904 = 0;
HEX3Atmp_47914 = 0;
HEX3Atmp_47914 = (Checkpoints_47784->Sup.len-1);
Res_47916 = 0;
Res_47916 = 0;
while (1) {
if (!(Res_47916 <= HEX3Atmp_47914)) goto LA4;
I_47904 = Res_47916;
LOC6 = (Current_47605.Line == Checkpoints_47784->data[I_47904].Line);
if (!(LOC6)) goto LA7;
LOC6 = (Current_47605.Fileindex == Checkpoints_47784->data[I_47904].Fileindex);
LA7: ;
if (!LOC6) goto LA8;
memset((void*)&LOC10, 0, sizeof(LOC10));
LOC10[0] = Tofilename_47579(Current_47605);
LOC10[1] = Coordtostr_47846(((NI) (Current_47605.Line)));
LOC10[2] = Coordtostr_47846(((NI) (Current_47605.Col)));
LOC11 = 0;
LOC11 = nsuFormatOpenArray(((NimStringDesc*) &TMP197254), LOC10, 3);
Messageout_47550(LOC11);
Result_47870 = NIM_TRUE;
goto BeforeRet;
LA8: ;
Res_47916 += 1;
} LA4: ;
BeforeRet: ;
return Result_47870;
}
N_NIMCALL(NI, Tocolumn_47582)(TY47532 Info_47584) {
NI Result_47834;
Result_47834 = 0;
Result_47834 = ((NI) (Info_47584.Col));
return Result_47834;
}
N_NIMCALL(void, Writeln_47841)(FILE* F_47844, NimStringDesc* X_47845) {
Write_3658(F_47844, X_47845);
Write_3658(F_47844, ((NimStringDesc*) &TMP198501));
}
N_NOINLINE(void, msgsInit)(void) {
Gnotes_47539 = 268435455;
Gerrorcounter_47540 = 0;
Ghintcounter_47541 = 0;
Gwarncounter_47542 = 0;
Gerrormax_47543 = 1;
asgnRefNoCycle((void**) &Filenames_47634, (TY39422*) newSeq(NTI39422, 0));
asgnRefNoCycle((void**) &Msgcontext_47652, (TY47635*) newSeq(NTI47635, 0));
asgnRefNoCycle((void**) &Checkpoints_47784, (TY47635*) newSeq(NTI47635, 0));
}

